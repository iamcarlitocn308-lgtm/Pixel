/**
 * 2D Platformer Game
 * Pure JavaScript implementation using Canvas API
 * No libraries or frameworks used
 */

// Game constants
const GAME = {
    BACKGROUND_COLOR: '#1e3a8a', // Blue background as requested
    TARGET_FPS: 60, // Target frames per second
    MS_PER_UPDATE: 1000 / 60, // Target time per frame in milliseconds
    DEBUG_MODE: true // Set to true to show debug info
};

// Player object
const player = {
    x: 100,
    y: 300,
    width: 40,
    height: 40,
    color: '#ef4444' // Red color
};

// Game state
let gameState = {
    canvas: null,
    ctx: null,
    lastTime: 0,
    accumulator: 0,
    isRunning: true,
    animationFrameId: null,
    debugInfo: {
        fps: 0,
        frameCount: 0,
        lastFpsUpdate: 0,
        lag: 0
    }
};

// Initialize the game when the page loads
window.addEventListener('load', initGame);

/**
 * Initialize the game
 */
function initGame() {
    console.log('Initializing 2D Platformer Game...');
    
    // Get canvas and context
    gameState.canvas = document.getElementById('gameCanvas');
    gameState.ctx = gameState.canvas.getContext('2d');
    
    // Set canvas to full screen
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Position player near bottom of screen
    positionPlayerNearBottom();
    
    // Hide loading overlay
    document.getElementById('loadingOverlay').style.display = 'none';
    
    // Start the game loop
    gameState.lastTime = performance.now();
    startGameLoop();
    
    console.log('Game initialized successfully!');
    console.log('Canvas size:', gameState.canvas.width, 'x', gameState.canvas.height);
    console.log('Player position:', player.x, player.y);
    console.log('Game loop started with target FPS:', GAME.TARGET_FPS);
}

/**
 * Position player near the bottom of the screen
 */
function positionPlayerNearBottom() {
    // Center player horizontally
    player.x = (gameState.canvas.width - player.width) / 2;
    
    // Position player near bottom (with some margin)
    player.y = gameState.canvas.height - player.height - 50;
}

/**
 * Resize canvas to fill the screen
 */
function resizeCanvas() {
    const container = gameState.canvas.parentElement;
    
    // Store previous canvas size
    const prevWidth = gameState.canvas.width;
    const prevHeight = gameState.canvas.height;
    
    // Set canvas dimensions to match container
    gameState.canvas.width = container.clientWidth;
    gameState.canvas.height = container.clientHeight;
    
    // Adjust player position to maintain relative position
    if (prevWidth > 0 && prevHeight > 0) {
        const xRatio = player.x / prevWidth;
        const yRatio = player.y / prevHeight;
        
        player.x = xRatio * gameState.canvas.width;
        player.y = yRatio * gameState.canvas.height;
        
        // Ensure player doesn't go off screen
        player.x = Math.max(0, Math.min(player.x, gameState.canvas.width - player.width));
        player.y = Math.max(0, Math.min(player.y, gameState.canvas.height - player.height));
    } else {
        // First time setup
        positionPlayerNearBottom();
    }
    
    console.log('Canvas resized to:', gameState.canvas.width, 'x', gameState.canvas.height);
    console.log('Player repositioned to:', player.x, player.y);
}

/**
 * Start the main game loop
 */
function startGameLoop() {
    // Cancel any existing animation frame
    if (gameState.animationFrameId) {
        cancelAnimationFrame(gameState.animationFrameId);
    }
    
    // Start the loop
    gameState.lastTime = performance.now();
    gameLoop();
}

/**
 * Main game loop using fixed timestep for consistent updates
 */
function gameLoop() {
    // Get current time
    const currentTime = performance.now();
    
    // Calculate elapsed time since last frame
    const elapsedTime = currentTime - gameState.lastTime;
    gameState.lastTime = currentTime;
    
    // Cap elapsed time to avoid spiral of death
    const clampedElapsedTime = Math.min(elapsedTime, 100);
    
    // Update debug info
    updateDebugInfo(currentTime, clampedElapsedTime);
    
    // Clear the canvas
    clearCanvas();
    
    // Draw game elements
    drawBackground();
    
    // Draw player
    drawPlayer();
    
    // Draw debug info if enabled
    if (GAME.DEBUG_MODE) {
        drawDebugInfo();
    }
    
    // Continue the game loop
    if (gameState.isRunning) {
        gameState.animationFrameId = requestAnimationFrame(gameLoop);
    }
}

/**
 * Clear the canvas with the background color
 */
function clearCanvas() {
    // Use a more efficient clear method
    gameState.ctx.fillStyle = GAME.BACKGROUND_COLOR;
    gameState.ctx.fillRect(0, 0, gameState.canvas.width, gameState.canvas.height);
}

/**
 * Draw the game background
 */
function drawBackground() {
    // Draw a simple gradient overlay on top of the solid blue background
    const gradient = gameState.ctx.createLinearGradient(0, 0, 0, gameState.canvas.height);
    gradient.addColorStop(0, 'rgba(30, 58, 138, 0.9)'); // Blue at top
    gradient.addColorStop(1, 'rgba(30, 58, 138, 0.7)'); // Slightly transparent at bottom
    
    gameState.ctx.fillStyle = gradient;
    gameState.ctx.fillRect(0, 0, gameState.canvas.width, gameState.canvas.height);
    
    // Draw a subtle grid pattern for visual interest
    drawGrid();
}

/**
 * Draw a subtle grid pattern
 */
function drawGrid() {
    const gridSize = 40;
    const gridColor = 'rgba(255, 255, 255, 0.05)';
    
    gameState.ctx.strokeStyle = gridColor;
    gameState.ctx.lineWidth = 1;
    
    // Draw vertical lines
    gameState.ctx.beginPath();
    for (let x = 0; x < gameState.canvas.width; x += gridSize) {
        gameState.ctx.moveTo(x, 0);
        gameState.ctx.lineTo(x, gameState.canvas.height);
    }
    gameState.ctx.stroke();
    
    // Draw horizontal lines
    gameState.ctx.beginPath();
    for (let y = 0; y < gameState.canvas.height; y += gridSize) {
        gameState.ctx.moveTo(0, y);
        gameState.ctx.lineTo(gameState.canvas.width, y);
    }
    gameState.ctx.stroke();
}

/**
 * Draw the player character
 */
function drawPlayer() {
    // Draw player body (red square)
    gameState.ctx.fillStyle = player.color;
    gameState.ctx.fillRect(player.x, player.y, player.width, player.height);
    
    // Add a subtle inner highlight for visual appeal
    gameState.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
    gameState.ctx.fillRect(player.x + 3, player.y + 3, player.width - 6, 8);
    
    // Add a darker border for definition
    gameState.ctx.strokeStyle = '#991b1b';
    gameState.ctx.lineWidth = 2;
    gameState.ctx.strokeRect(player.x, player.y, player.width, player.height);
    
    // Draw player "eyes" (small white dots)
    gameState.ctx.fillStyle = '#ffffff';
    gameState.ctx.fillRect(player.x + 10, player.y + 12, 6, 6);
    gameState.ctx.fillRect(player.x + player.width - 16, player.y + 12, 6, 6);
}

/**
 * Update debug information
 * @param {number} currentTime - Current timestamp
 * @param {number} elapsedTime - Elapsed time since last frame
 */
function updateDebugInfo(currentTime, elapsedTime) {
    gameState.debugInfo.frameCount++;
    
    // Update FPS every second
    if (currentTime - gameState.debugInfo.lastFpsUpdate >= 1000) {
        gameState.debugInfo.fps = Math.round(
            (gameState.debugInfo.frameCount * 1000) / (currentTime - gameState.debugInfo.lastFpsUpdate)
        );
        gameState.debugInfo.frameCount = 0;
        gameState.debugInfo.lastFpsUpdate = currentTime;
    }
    
    // Calculate lag (difference between actual and target frame time)
    gameState.debugInfo.lag = Math.abs(elapsedTime - GAME.MS_PER_UPDATE);
}

/**
 * Draw debug information on the canvas
 */
function drawDebugInfo() {
    const ctx = gameState.ctx;
    const debugX = 10;
    let debugY = 30;
    const lineHeight = 20;
    
    // Draw debug background panel
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(5, 5, 240, 160);
    
    // Draw debug text
    ctx.fillStyle = '#4cc9f0';
    ctx.font = '16px monospace';
    ctx.textAlign = 'left';
    
    // Game Loop Info header
    ctx.fillStyle = '#ffcc00';
    ctx.fillText('=== GAME LOOP INFO ===', debugX, debugY);
    debugY += lineHeight;
    
    // FPS
    ctx.fillStyle = gameState.debugInfo.fps >= 55 ? '#4ade80' : '#f87171';
    ctx.fillText(`FPS: ${gameState.debugInfo.fps} (Target: ${GAME.TARGET_FPS})`, debugX, debugY);
    debugY += lineHeight;
    
    // Frame time
    const frameTime = 1000 / Math.max(gameState.debugInfo.fps, 1);
    ctx.fillStyle = '#4cc9f0';
    ctx.fillText(`Frame: ${frameTime.toFixed(1)}ms`, debugX, debugY);
    debugY += lineHeight;
    
    // Lag
    ctx.fillStyle = gameState.debugInfo.lag < 2 ? '#4ade80' : '#f87171';
    ctx.fillText(`Lag: ${gameState.debugInfo.lag.toFixed(2)}ms`, debugX, debugY);
    debugY += lineHeight;
    
    // Canvas size
    ctx.fillStyle = '#c084fc';
    ctx.fillText(`Canvas: ${gameState.canvas.width} x ${gameState.canvas.height}`, debugX, debugY);
    debugY += lineHeight;
    
    // Game state
    ctx.fillStyle = gameState.isRunning ? '#4ade80' : '#f87171';
    ctx.fillText(`State: ${gameState.isRunning ? 'RUNNING' : 'PAUSED'}`, debugX, debugY);
    debugY += lineHeight;
    
    // Player info header
    ctx.fillStyle = '#ffcc00';
    ctx.fillText('=== PLAYER INFO ===', debugX, debugY);
    debugY += lineHeight;
    
    // Player position
    ctx.fillStyle = '#ef4444';
    ctx.fillText(`Position: (${Math.floor(player.x)}, ${Math.floor(player.y)})`, debugX, debugY);
    debugY += lineHeight;
    
    // Player size
    ctx.fillText(`Size: ${player.width} x ${player.height}`, debugX, debugY);
}

// Handle window focus/blur to pause/resume game
window.addEventListener('blur', () => {
    console.log('Game paused (window lost focus)');
    gameState.isRunning = false;
    if (gameState.animationFrameId) {
        cancelAnimationFrame(gameState.animationFrameId);
        gameState.animationFrameId = null;
    }
});

window.addEventListener('focus', () => {
    console.log('Game resumed (window gained focus)');
    if (!gameState.isRunning) {
        gameState.isRunning = true;
        startGameLoop();
    }
});

// Add keyboard shortcut to toggle debug mode (D key)
window.addEventListener('keydown', (e) => {
    if (e.key === 'd' || e.key === 'D') {
        GAME.DEBUG_MODE = !GAME.DEBUG_MODE;
        console.log(`Debug mode ${GAME.DEBUG_MODE ? 'enabled' : 'disabled'}`);
    }
});

// Export for debugging
window.gameState = gameState;
window.GAME = GAME;
window.player = player;
