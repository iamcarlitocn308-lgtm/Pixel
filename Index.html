/**
 * 2D Platformer Game
 * Pure JavaScript implementation using Canvas API
 * No libraries or frameworks used
 */

// Game constants
const GAME = {
    BACKGROUND_COLOR: '#1e3a8a', // Blue background as requested
    TARGET_FPS: 60, // Target frames per second
    MS_PER_UPDATE: 1000 / 60, // Target time per frame in milliseconds
    DEBUG_MODE: true, // Set to true to show debug info
    PLAYER_SPEED: 300, // Pixels per second
    PLAYER_FRICTION: 0.85, // Friction coefficient (0-1)
    GRAVITY: 900, // Pixels per second squared
    JUMP_FORCE: -400 // Negative because up is negative Y
};

// Player object
const player = {
    x: 100,
    y: 300,
    width: 40,
    height: 40,
    color: '#ef4444', // Red color
    velocityX: 0,
    velocityY: 0,
    maxSpeed: 8,
    isOnGround: false,
    canJump: true,
    jumpCooldown: 0
};

// Platforms array
const platforms = [
    // Format: {x, y, width, height, color}
    { x: 50, y: 450, width: 200, height: 20, color: '#10b981' },
    { x: 300, y: 350, width: 150, height: 20, color: '#3b82f6' },
    { x: 500, y: 250, width: 180, height: 20, color: '#8b5cf6' },
    { x: 200, y: 150, width: 120, height: 20, color: '#f59e0b' },
    { x: 600, y: 400, width: 100, height: 20, color: '#ec4899' },
    // Ground platform
    { x: 0, y: 550, width: 800, height: 50, color: '#64748b' }
];

// Keyboard input state
const keys = {
    a: false,
    d: false,
    w: false,
    s: false,
    arrowLeft: false,
    arrowRight: false,
    arrowUp: false,
    arrowDown: false,
    space: false
};

// Game state
let gameState = {
    canvas: null,
    ctx: null,
    lastTime: 0,
    accumulator: 0,
    isRunning: true,
    animationFrameId: null,
    debugInfo: {
        fps: 0,
        frameCount: 0,
        lastFpsUpdate: 0,
        lag: 0
    }
};

// Initialize the game when the page loads
window.addEventListener('load', initGame);

/**
 * Initialize the game
 */
function initGame() {
    console.log('Initializing 2D Platformer Game...');
    
    // Get canvas and context
    gameState.canvas = document.getElementById('gameCanvas');
    gameState.ctx = gameState.canvas.getContext('2d');
    
    // Set up keyboard event listeners
    setupKeyboardControls();
    
    // Set canvas to full screen
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Position player on first platform
    positionPlayerOnStartPlatform();
    
    // Hide loading overlay
    document.getElementById('loadingOverlay').style.display = 'none';
    
    // Start the game loop
    gameState.lastTime = performance.now();
    startGameLoop();
    
    console.log('Game initialized successfully!');
    console.log('Canvas size:', gameState.canvas.width, 'x', gameState.canvas.height);
    console.log('Player position:', player.x, player.y);
    console.log('Platforms created:', platforms.length);
    console.log('Game loop started with target FPS:', GAME.TARGET_FPS);
}

/**
 * Set up keyboard event listeners
 */
function setupKeyboardControls() {
    // Key down event
    window.addEventListener('keydown', (e) => {
        switch (e.key.toLowerCase()) {
            case 'a':
                keys.a = true;
                break;
            case 'd':
                keys.d = true;
                break;
            case 'w':
                keys.w = true;
                if (player.isOnGround && player.canJump) {
                    player.velocityY = GAME.JUMP_FORCE;
                    player.isOnGround = false;
                    player.canJump = false;
                    player.jumpCooldown = 0.2; // Small cooldown to prevent double jumps
                    console.log('Jump!');
                }
                break;
            case 's':
                keys.s = true;
                break;
            case ' ':
                keys.space = true;
                if (player.isOnGround && player.canJump) {
                    player.velocityY = GAME.JUMP_FORCE;
                    player.isOnGround = false;
                    player.canJump = false;
                    player.jumpCooldown = 0.2; // Small cooldown to prevent double jumps
                    console.log('Jump! (Space)');
                }
                break;
            case 'arrowleft':
            case 'left':
                keys.arrowLeft = true;
                break;
            case 'arrowright':
            case 'right':
                keys.arrowRight = true;
                break;
            case 'arrowup':
            case 'up':
                keys.arrowUp = true;
                if (player.isOnGround && player.canJump) {
                    player.velocityY = GAME.JUMP_FORCE;
                    player.isOnGround = false;
                    player.canJump = false;
                    player.jumpCooldown = 0.2; // Small cooldown to prevent double jumps
                    console.log('Jump! (Arrow Up)');
                }
                break;
            case 'arrowdown':
            case 'down':
                keys.arrowDown = true;
                break;
            case 'd':
                // Don't toggle debug if shift is held
                if (!e.shiftKey) {
                    GAME.DEBUG_MODE = !GAME.DEBUG_MODE;
                    console.log(`Debug mode ${GAME.DEBUG_MODE ? 'enabled' : 'disabled'}`);
                }
                break;
        }
    });
    
    // Key up event
    window.addEventListener('keyup', (e) => {
        switch (e.key.toLowerCase()) {
            case 'a':
                keys.a = false;
                break;
            case 'd':
                keys.d = false;
                break;
            case 'w':
                keys.w = false;
                break;
            case 's':
                keys.s = false;
                break;
            case ' ':
                keys.space = false;
                break;
            case 'arrowleft':
            case 'left':
                keys.arrowLeft = false;
                break;
            case 'arrowright':
            case 'right':
                keys.arrowRight = false;
                break;
            case 'arrowup':
            case 'up':
                keys.arrowUp = false;
                break;
            case 'arrowdown':
            case 'down':
                keys.arrowDown = false;
                break;
        }
    });
    
    // Prevent arrow key scrolling
    window.addEventListener('keydown', (e) => {
        if ([32, 37, 38, 39, 40].indexOf(e.keyCode) > -1) {
            e.preventDefault();
        }
    }, false);
}

/**
 * Position player on the starting platform
 */
function positionPlayerOnStartPlatform() {
    // Start on the first platform
    const startPlatform = platforms[0];
    player.x = startPlatform.x + startPlatform.width / 2 - player.width / 2;
    player.y = startPlatform.y - player.height;
}

/**
 * Resize canvas to fill the screen
 */
function resizeCanvas() {
    const container = gameState.canvas.parentElement;
    
    // Store previous canvas size
    const prevWidth = gameState.canvas.width;
    const prevHeight = gameState.canvas.height;
    
    // Set canvas dimensions to match container
    gameState.canvas.width = container.clientWidth;
    gameState.canvas.height = container.clientHeight;
    
    // Adjust player position to maintain relative position
    if (prevWidth > 0 && prevHeight > 0) {
        const xRatio = player.x / prevWidth;
        const yRatio = player.y / prevHeight;
        
        player.x = xRatio * gameState.canvas.width;
        player.y = yRatio * gameState.canvas.height;
        
        // Ensure player doesn't go off screen
        player.x = Math.max(0, Math.min(player.x, gameState.canvas.width - player.width));
        player.y = Math.max(0, Math.min(player.y, gameState.canvas.height - player.height));
    } else {
        // First time setup
        positionPlayerOnStartPlatform();
    }
    
    // Adjust platforms to maintain relative positions
    for (let i = 0; i < platforms.length; i++) {
        const platform = platforms[i];
        if (prevWidth > 0 && prevHeight > 0) {
            const xRatio = platform.x / prevWidth;
            const yRatio = platform.y / prevHeight;
            
            platform.x = xRatio * gameState.canvas.width;
            platform.y = yRatio * gameState.canvas.height;
            
            // Scale platform width proportionally
            platform.width = (platform.width / prevWidth) * gameState.canvas.width;
        }
        
        // Ensure ground platform spans full width
        if (i === platforms.length - 1) { // Ground platform is last
            platform.x = 0;
            platform.width = gameState.canvas.width;
            platform.y = gameState.canvas.height - platform.height;
        }
    }
    
    console.log('Canvas resized to:', gameState.canvas.width, 'x', gameState.canvas.height);
    console.log('Player repositioned to:', player.x, player.y);
}

/**
 * Start the main game loop
 */
function startGameLoop() {
    // Cancel any existing animation frame
    if (gameState.animationFrameId) {
        cancelAnimationFrame(gameState.animationFrameId);
    }
    
    // Start the loop
    gameState.lastTime = performance.now();
    gameLoop();
}

/**
 * Main game loop using fixed timestep for consistent updates
 */
function gameLoop() {
    // Get current time
    const currentTime = performance.now();
    
    // Calculate elapsed time since last frame
    const elapsedTime = currentTime - gameState.lastTime;
    gameState.lastTime = currentTime;
    
    // Cap elapsed time to avoid spiral of death
    const clampedElapsedTime = Math.min(elapsedTime, 100);
    
    // Calculate delta time for smooth movement
    const deltaTime = clampedElapsedTime / 1000; // Convert to seconds
    
    // Update game state
    updatePlayer(deltaTime);
    
    // Update debug info
    updateDebugInfo(currentTime, clampedElapsedTime);
    
    // Clear the canvas
    clearCanvas();
    
    // Draw game elements
    drawBackground();
    
    // Draw platforms
    drawPlatforms();
    
    // Draw player
    drawPlayer();
    
    // Draw debug info if enabled
    if (GAME.DEBUG_MODE) {
        drawDebugInfo();
    }
    
    // Continue the game loop
    if (gameState.isRunning) {
        gameState.animationFrameId = requestAnimationFrame(gameLoop);
    }
}

/**
 * Check collision between player and a platform
 * @param {Object} platform - Platform object
 * @returns {boolean} - True if player is colliding with platform from top
 */
function checkPlatformCollision(platform) {
    // Check if player is above the platform and moving downward
    const isAbove = player.y + player.height <= platform.y + 5; // Small tolerance
    const isMovingDown = player.velocityY > 0;
    
    // Check if player is horizontally within platform bounds
    const playerRight = player.x + player.width;
    const playerBottom = player.y + player.height;
    const platformRight = platform.x + platform.width;
    
    const isHorizontallyAligned = 
        player.x < platformRight && 
        playerRight > platform.x;
    
    // Check if player's bottom is near platform top
    const isTouchingTop = playerBottom >= platform.y && playerBottom <= platform.y + 10;
    
    return isAbove && isMovingDown && isHorizontallyAligned && isTouchingTop;
}

/**
 * Update player position based on velocity and input
 * @param {number} deltaTime - Time since last frame in seconds
 */
function updatePlayer(deltaTime) {
    // Update jump cooldown
    if (player.jumpCooldown > 0) {
        player.jumpCooldown -= deltaTime;
    } else if (!player.canJump && player.isOnGround) {
        player.canJump = true; // Reset jump ability when back on ground
    }
    
    // Handle horizontal movement input
    let moveLeft = keys.a || keys.arrowLeft;
    let moveRight = keys.d || keys.arrowRight;
    
    // Apply acceleration based on input
    if (moveLeft && !moveRight) {
        // Move left
        player.velocityX -= GAME.PLAYER_SPEED * deltaTime;
    } else if (moveRight && !moveLeft) {
        // Move right
        player.velocityX += GAME.PLAYER_SPEED * deltaTime;
    } else {
        // Apply friction when no horizontal input
        player.velocityX *= GAME.PLAYER_FRICTION;
    }
    
    // Limit maximum speed
    if (Math.abs(player.velocityX) > player.maxSpeed) {
        player.velocityX = player.maxSpeed * Math.sign(player.velocityX);
    }
    
    // Apply very small friction at all times to prevent tiny perpetual movement
    if (Math.abs(player.velocityX) < 0.1) {
        player.velocityX = 0;
    }
    
    // Apply gravity (constantly pulls player down)
    player.velocityY += GAME.GRAVITY * deltaTime;
    
    // Update position based on velocity
    player.x += player.velocityX;
    player.y += player.velocityY;
    
    // Reset ground state - will be set to true if on any platform
    player.isOnGround = false;
    
    // Check collisions with all platforms
    for (const platform of platforms) {
        if (checkPlatformCollision(platform)) {
            // Land on platform
            player.y = platform.y - player.height;
            player.velocityY = 0;
            player.isOnGround = true;
            break; // Only stand on one platform at a time
        }
    }
    
    // Keep player within canvas horizontal bounds
    if (player.x < 0) {
        player.x = 0;
        player.velocityX = 0; // Stop movement at boundary
    } else if (player.x + player.width > gameState.canvas.width) {
        player.x = gameState.canvas.width - player.width;
        player.velocityX = 0; // Stop movement at boundary
    }
    
    // Prevent player from going above the top of the screen
    if (player.y < 0) {
        player.y = 0;
        player.velocityY = 0;
    }
}

/**
 * Draw all platforms
 */
function drawPlatforms() {
    for (const platform of platforms) {
        // Draw platform body
        gameState.ctx.fillStyle = platform.color;
        gameState.ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        
        // Draw platform top highlight
        gameState.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        gameState.ctx.fillRect(platform.x, platform.y, platform.width, 4);
        
        // Draw platform shadow
        gameState.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        gameState.ctx.fillRect(platform.x, platform.y + platform.height, platform.width, 3);
        
        // Draw platform sides
        gameState.ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        gameState.ctx.lineWidth = 2;
        gameState.ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
        
        // Draw platform label for debugging
        if (GAME.DEBUG_MODE) {
            gameState.ctx.fillStyle = '#ffffff';
            gameState.ctx.font = '12px monospace';
            gameState.ctx.textAlign = 'center';
            gameState.ctx.fillText(
                `Platform ${platforms.indexOf(platform) + 1}`,
                platform.x + platform.width / 2,
                platform.y + platform.height / 2 + 4
            );
        }
    }
}

/**
 * Clear the canvas with the background color
 */
function clearCanvas() {
    // Use a more efficient clear method
    gameState.ctx.fillStyle = GAME.BACKGROUND_COLOR;
    gameState.ctx.fillRect(0, 0, gameState.canvas.width, gameState.canvas.height);
}

/**
 * Draw the game background
 */
function drawBackground() {
    // Draw a simple gradient overlay on top of the solid blue background
    const gradient = gameState.ctx.createLinearGradient(0, 0, 0, gameState.canvas.height);
    gradient.addColorStop(0, 'rgba(30, 58, 138, 0.9)'); // Blue at top
    gradient.addColorStop(1, 'rgba(30, 58, 138, 0.7)'); // Slightly transparent at bottom
    
    gameState.ctx.fillStyle = gradient;
    gameState.ctx.fillRect(0, 0, gameState.canvas.width, gameState.canvas.height);
    
    // Draw a subtle grid pattern for visual interest
    drawGrid();
}

/**
 * Draw a subtle grid pattern
 */
function drawGrid() {
    const gridSize = 40;
    const gridColor = 'rgba(255, 255, 255, 0.05)';
    
    gameState.ctx.strokeStyle = gridColor;
    gameState.ctx.lineWidth = 1;
    
    // Draw vertical lines
    gameState.ctx.beginPath();
    for (let x = 0; x < gameState.canvas.width; x += gridSize) {
        gameState.ctx.moveTo(x, 0);
        gameState.ctx.lineTo(x, gameState.canvas.height);
    }
    gameState.ctx.stroke();
    
    // Draw horizontal lines
    gameState.ctx.beginPath();
    for (let y = 0; y < gameState.canvas.height; y += gridSize) {
        gameState.ctx.moveTo(0, y);
        gameState.ctx.lineTo(gameState.canvas.width, y);
    }
    gameState.ctx.stroke();
}

/**
 * Draw the player character
 */
function drawPlayer() {
    // Draw player shadow (only when not on ground)
    if (!player.isOnGround) {
        gameState.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        const shadowSize = player.width * (0.8 + 0.2 * (1 - Math.abs(player.velocityY) / 20));
        const shadowX = player.x + (player.width - shadowSize) / 2;
        const shadowY = player.y + player.height + 5;
        
        gameState.ctx.beginPath();
        gameState.ctx.ellipse(
            shadowX + shadowSize / 2,
            shadowY,
            shadowSize / 2,
            5,
            0, 0, Math.PI * 2
        );
        gameState.ctx.fill();
    }
    
    // Draw player body (red square)
    gameState.ctx.fillStyle = player.color;
    gameState.ctx.fillRect(player.x, player.y, player.width, player.height);
    
    // Add a subtle inner highlight for visual appeal
    gameState.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
    gameState.ctx.fillRect(player.x + 3, player.y + 3, player.width - 6, 8);
    
    // Add a darker border for definition
    gameState.ctx.strokeStyle = '#991b1b';
    gameState.ctx.lineWidth = 2;
    gameState.ctx.strokeRect(player.x, player.y, player.width, player.height);
    
    // Draw player "eyes" (small white dots)
    gameState.ctx.fillStyle = '#ffffff';
    gameState.ctx.fillRect(player.x + 10, player.y + 12, 6, 6);
    gameState.ctx.fillRect(player.x + player.width - 16, player.y + 12, 6, 6);
    
    // Draw direction indicator based on velocity
    if (Math.abs(player.velocityX) > 0.5) {
        gameState.ctx.fillStyle = player.velocityX > 0 ? '#22c55e' : '#3b82f6';
        const indicatorSize = 8;
        const indicatorX = player.velocityX > 0 ? 
            player.x + player.width + 5 : 
            player.x - indicatorSize - 5;
        gameState.ctx.fillRect(
            indicatorX, 
            player.y + player.height / 2 - indicatorSize / 2, 
            indicatorSize, 
            indicatorSize
        );
    }
    
    // Draw jump indicator
    if (!player.isOnGround) {
        gameState.ctx.fillStyle = player.velocityY < 0 ? '#f59e0b' : '#ef4444';
        const jumpIndicatorSize = 6;
        const jumpIndicatorX = player.x + player.width / 2 - jumpIndicatorSize / 2;
        const jumpIndicatorY = player.velocityY < 0 ? 
            player.y - jumpIndicatorSize - 5 : 
            player.y + player.height + 5;
        gameState.ctx.fillRect(
            jumpIndicatorX,
            jumpIndicatorY,
            jumpIndicatorSize,
            jumpIndicatorSize
        );
    }
}

/**
 * Update debug information
 * @param {number} currentTime - Current timestamp
 * @param {number} elapsedTime - Elapsed time since last frame
 */
function updateDebugInfo(currentTime, elapsedTime) {
    gameState.debugInfo.frameCount++;
    
    // Update FPS every second
    if (currentTime - gameState.debugInfo.lastFpsUpdate >= 1000) {
        gameState.debugInfo.fps = Math.round(
            (gameState.debugInfo.frameCount * 1000) / (currentTime - gameState.debugInfo.lastFpsUpdate)
        );
        gameState.debugInfo.frameCount = 0;
        gameState.debugInfo.lastFpsUpdate = currentTime;
    }
    
    // Calculate lag (difference between actual and target frame time)
    gameState.debugInfo.lag = Math.abs(elapsedTime - GAME.MS_PER_UPDATE);
}

/**
 * Draw debug information on the canvas
 */
function drawDebugInfo() {
    const ctx = gameState.ctx;
    const debugX = 10;
    let debugY = 30;
    const lineHeight = 20;
    
    // Draw debug background panel
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(5, 5, 280, 220);
    
    // Draw debug text
    ctx.fillStyle = '#4cc9f0';
    ctx.font = '16px monospace';
    ctx.textAlign = 'left';
    
    // Game Loop Info header
    ctx.fillStyle = '#ffcc00';
    ctx.fillText('=== GAME LOOP INFO ===', debugX, debugY);
    debugY += lineHeight;
    
    // FPS
    ctx.fillStyle = gameState.debugInfo.fps >= 55 ? '#4ade80' : '#f87171';
    ctx.fillText(`FPS: ${gameState.debugInfo.fps} (Target: ${GAME.TARGET_FPS})`, debugX, debugY);
    debugY += lineHeight;
    
    // Frame time
    const frameTime = 1000 / Math.max(gameState.debugInfo.fps, 1);
    ctx.fillStyle = '#4cc9f0';
    ctx.fillText(`Frame: ${frameTime.toFixed(1)}ms`, debugX, debugY);
    debugY += lineHeight;
    
    // Lag
    ctx.fillStyle = gameState.debugInfo.lag < 2 ? '#4ade80' : '#f87171';
    ctx.fillText(`Lag: ${gameState.debugInfo.lag.toFixed(2)}ms`, debugX, debugY);
    debugY += lineHeight;
    
    // Canvas size
    ctx.fillStyle = '#c084fc';
    ctx.fillText(`Canvas: ${gameState.canvas.width} x ${gameState.canvas.height}`, debugX, debugY);
    debugY += lineHeight;
    
    // Game state
    ctx.fillStyle = gameState.isRunning ? '#4ade80' : '#f87171';
    ctx.fillText(`State: ${gameState.isRunning ? 'RUNNING' : 'PAUSED'}`, debugX, debugY);
    debugY += lineHeight;
    
    // Player info header
    ctx.fillStyle = '#ffcc00';
    ctx.fillText('=== PLAYER INFO ===', debugX, debugY);
    debugY += lineHeight;
    
    // Player position
    ctx.fillStyle = '#ef4444';
    ctx.fillText(`Position: (${Math.floor(player.x)}, ${Math.floor(player.y)})`, debugX, debugY);
    debugY += lineHeight;
    
    // Player velocity
    ctx.fillStyle = player.velocityX !== 0 ? '#22c55e' : '#94a3b8';
    ctx.fillText(`Velocity X: ${player.velocityX.toFixed(2)}`, debugX, debugY);
    debugY += lineHeight;
    
    ctx.fillStyle = player.velocityY !== 0 ? '#f59e0b' : '#94a3b8';
    ctx.fillText(`Velocity Y: ${player.velocityY.toFixed(2)}`, debugX, debugY);
    debugY += lineHeight;
    
    // Player state
    ctx.fillStyle = player.isOnGround ? '#22c55e' : '#f59e0b';
    ctx.fillText(`On Ground: ${player.isOnGround ? 'YES' : 'NO'}`, debugX, debugY);
    debugY += lineHeight;
    
    ctx.fillStyle = player.canJump ? '#22c55e' : '#ef4444';
    ctx.fillText(`Can Jump: ${player.canJump ? 'YES' : 'NO'}`, debugX, debugY);
    debugY += lineHeight;
    
    // Platform info
    ctx.fillStyle = '#ffcc00';
    ctx.fillText('=== PLATFORMS ===', debugX, debugY);
    debugY += lineHeight;
    
    ctx.fillStyle = '#c084fc';
    ctx.fillText(`Active Platforms: ${platforms.length}`, debugX, debugY);
}

// Handle window focus/blur to pause/resume game
window.addEventListener('blur', () => {
    console.log('Game paused (window lost focus)');
    gameState.isRunning = false;
    if (gameState.animationFrameId) {
        cancelAnimationFrame(gameState.animationFrameId);
        gameState.animationFrameId = null;
    }
});

window.addEventListener('focus', () => {
    console.log('Game resumed (window gained focus)');
    if (!gameState.isRunning) {
        gameState.isRunning = true;
        startGameLoop();
    }
});

// Export for debugging
window.gameState = gameState;
window.GAME = GAME;
window.player = player;
window.keys = keys;
window.platforms = platforms;
