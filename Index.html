/**
 * 2D Platformer Game
 * Pure JavaScript implementation using Canvas API
 * No libraries or frameworks used
 */

// Game constants
const GAME = {
    BACKGROUND_COLOR: '#1e3a8a', // Blue background as requested
    TARGET_FPS: 60, // Target frames per second
    MS_PER_UPDATE: 1000 / 60, // Target time per frame in milliseconds
    DEBUG_MODE: true, // Set to true to show debug info
    PLAYER_SPEED: 300, // Pixels per second
    PLAYER_FRICTION: 0.85 // Friction coefficient (0-1)
};

// Player object
const player = {
    x: 100,
    y: 300,
    width: 40,
    height: 40,
    color: '#ef4444', // Red color
    velocityX: 0,
    velocityY: 0,
    maxSpeed: 8
};

// Keyboard input state
const keys = {
    a: false,
    d: false,
    w: false,
    s: false,
    arrowLeft: false,
    arrowRight: false,
    arrowUp: false,
    arrowDown: false,
    space: false
};

// Game state
let gameState = {
    canvas: null,
    ctx: null,
    lastTime: 0,
    accumulator: 0,
    isRunning: true,
    animationFrameId: null,
    debugInfo: {
        fps: 0,
        frameCount: 0,
        lastFpsUpdate: 0,
        lag: 0
    }
};

// Initialize the game when the page loads
window.addEventListener('load', initGame);

/**
 * Initialize the game
 */
function initGame() {
    console.log('Initializing 2D Platformer Game...');
    
    // Get canvas and context
    gameState.canvas = document.getElementById('gameCanvas');
    gameState.ctx = gameState.canvas.getContext('2d');
    
    // Set up keyboard event listeners
    setupKeyboardControls();
    
    // Set canvas to full screen
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Position player near bottom of screen
    positionPlayerNearBottom();
    
    // Hide loading overlay
    document.getElementById('loadingOverlay').style.display = 'none';
    
    // Start the game loop
    gameState.lastTime = performance.now();
    startGameLoop();
    
    console.log('Game initialized successfully!');
    console.log('Canvas size:', gameState.canvas.width, 'x', gameState.canvas.height);
    console.log('Player position:', player.x, player.y);
    console.log('Game loop started with target FPS:', GAME.TARGET_FPS);
}

/**
 * Set up keyboard event listeners
 */
function setupKeyboardControls() {
    // Key down event
    window.addEventListener('keydown', (e) => {
        switch (e.key.toLowerCase()) {
            case 'a':
                keys.a = true;
                break;
            case 'd':
                keys.d = true;
                break;
            case 'w':
                keys.w = true;
                break;
            case 's':
                keys.s = true;
                break;
            case ' ':
                keys.space = true;
                break;
            case 'arrowleft':
            case 'left':
                keys.arrowLeft = true;
                break;
            case 'arrowright':
            case 'right':
                keys.arrowRight = true;
                break;
            case 'arrowup':
            case 'up':
                keys.arrowUp = true;
                break;
            case 'arrowdown':
            case 'down':
                keys.arrowDown = true;
                break;
            case 'd':
                // Don't toggle debug if shift is held
                if (!e.shiftKey) {
                    GAME.DEBUG_MODE = !GAME.DEBUG_MODE;
                    console.log(`Debug mode ${GAME.DEBUG_MODE ? 'enabled' : 'disabled'}`);
                }
                break;
        }
    });
    
    // Key up event
    window.addEventListener('keyup', (e) => {
        switch (e.key.toLowerCase()) {
            case 'a':
                keys.a = false;
                break;
            case 'd':
                keys.d = false;
                break;
            case 'w':
                keys.w = false;
                break;
            case 's':
                keys.s = false;
                break;
            case ' ':
                keys.space = false;
                break;
            case 'arrowleft':
            case 'left':
                keys.arrowLeft = false;
                break;
            case 'arrowright':
            case 'right':
                keys.arrowRight = false;
                break;
            case 'arrowup':
            case 'up':
                keys.arrowUp = false;
                break;
            case 'arrowdown':
            case 'down':
                keys.arrowDown = false;
                break;
        }
    });
    
    // Prevent arrow key scrolling
    window.addEventListener('keydown', (e) => {
        if ([32, 37, 38, 39, 40].indexOf(e.keyCode) > -1) {
            e.preventDefault();
        }
    }, false);
}

/**
 * Position player near the bottom of the screen
 */
function positionPlayerNearBottom() {
    // Center player horizontally
    player.x = (gameState.canvas.width - player.width) / 2;
    
    // Position player near bottom (with some margin)
    player.y = gameState.canvas.height - player.height - 50;
}

/**
 * Resize canvas to fill the screen
 */
function resizeCanvas() {
    const container = gameState.canvas.parentElement;
    
    // Store previous canvas size
    const prevWidth = gameState.canvas.width;
    const prevHeight = gameState.canvas.height;
    
    // Set canvas dimensions to match container
    gameState.canvas.width = container.clientWidth;
    gameState.canvas.height = container.clientHeight;
    
    // Adjust player position to maintain relative position
    if (prevWidth > 0 && prevHeight > 0) {
        const xRatio = player.x / prevWidth;
        const yRatio = player.y / prevHeight;
        
        player.x = xRatio * gameState.canvas.width;
        player.y = yRatio * gameState.canvas.height;
        
        // Ensure player doesn't go off screen
        player.x = Math.max(0, Math.min(player.x, gameState.canvas.width - player.width));
        player.y = Math.max(0, Math.min(player.y, gameState.canvas.height - player.height));
    } else {
        // First time setup
        positionPlayerNearBottom();
    }
    
    console.log('Canvas resized to:', gameState.canvas.width, 'x', gameState.canvas.height);
    console.log('Player repositioned to:', player.x, player.y);
}

/**
 * Start the main game loop
 */
function startGameLoop() {
    // Cancel any existing animation frame
    if (gameState.animationFrameId) {
        cancelAnimationFrame(gameState.animationFrameId);
    }
    
    // Start the loop
    gameState.lastTime = performance.now();
    gameLoop();
}

/**
 * Main game loop using fixed timestep for consistent updates
 */
function gameLoop() {
    // Get current time
    const currentTime = performance.now();
    
    // Calculate elapsed time since last frame
    const elapsedTime = currentTime - gameState.lastTime;
    gameState.lastTime = currentTime;
    
    // Cap elapsed time to avoid spiral of death
    const clampedElapsedTime = Math.min(elapsedTime, 100);
    
    // Calculate delta time for smooth movement
    const deltaTime = clampedElapsedTime / 1000; // Convert to seconds
    
    // Update game state
    updatePlayer(deltaTime);
    
    // Update debug info
    updateDebugInfo(currentTime, clampedElapsedTime);
    
    // Clear the canvas
    clearCanvas();
    
    // Draw game elements
    drawBackground();
    
    // Draw player
    drawPlayer();
    
    // Draw debug info if enabled
    if (GAME.DEBUG_MODE) {
        drawDebugInfo();
    }
    
    // Continue the game loop
    if (gameState.isRunning) {
        gameState.animationFrameId = requestAnimationFrame(gameLoop);
    }
}

/**
 * Update player position based on velocity and input
 * @param {number} deltaTime - Time since last frame in seconds
 */
function updatePlayer(deltaTime) {
    // Handle horizontal movement input
    let moveLeft = keys.a || keys.arrowLeft;
    let moveRight = keys.d || keys.arrowRight;
    
    // Apply acceleration based on input
    if (moveLeft && !moveRight) {
        // Move left
        player.velocityX -= GAME.PLAYER_SPEED * deltaTime;
    } else if (moveRight && !moveLeft) {
        // Move right
        player.velocityX += GAME.PLAYER_SPEED * deltaTime;
    } else {
        // Apply friction when no horizontal input
        player.velocityX *= GAME.PLAYER_FRICTION;
    }
    
    // Limit maximum speed
    if (Math.abs(player.velocityX) > player.maxSpeed) {
        player.velocityX = player.maxSpeed * Math.sign(player.velocityX);
    }
    
    // Apply very small friction at all times to prevent tiny perpetual movement
    if (Math.abs(player.velocityX) < 0.1) {
        player.velocityX = 0;
    }
    
    // Update position based on velocity
    player.x += player.velocityX;
    
    // Keep player within canvas bounds
    if (player.x < 0) {
        player.x = 0;
        player.velocityX = 0; // Stop movement at boundary
    } else if (player.x + player.width > gameState.canvas.width) {
        player.x = gameState.canvas.width - player.width;
        player.velocityX = 0; // Stop movement at boundary
    }
}

/**
 * Clear the canvas with the background color
 */
function clearCanvas() {
    // Use a more efficient clear method
    gameState.ctx.fillStyle = GAME.BACKGROUND_COLOR;
    gameState.ctx.fillRect(0, 0, gameState.canvas.width, gameState.canvas.height);
}

/**
 * Draw the game background
 */
function drawBackground() {
    // Draw a simple gradient overlay on top of the solid blue background
    const gradient = gameState.ctx.createLinearGradient(0, 0, 0, gameState.canvas.height);
    gradient.addColorStop(0, 'rgba(30, 58, 138, 0.9)'); // Blue at top
    gradient.addColorStop(1, 'rgba(30, 58, 138, 0.7)'); // Slightly transparent at bottom
    
    gameState.ctx.fillStyle = gradient;
    gameState.ctx.fillRect(0, 0, gameState.canvas.width, gameState.canvas.height);
    
    // Draw a subtle grid pattern for visual interest
    drawGrid();
}

/**
 * Draw a subtle grid pattern
 */
function drawGrid() {
    const gridSize = 40;
    const gridColor = 'rgba(255, 255, 255, 0.05)';
    
    gameState.ctx.strokeStyle = gridColor;
    gameState.ctx.lineWidth = 1;
    
    // Draw vertical lines
    gameState.ctx.beginPath();
    for (let x = 0; x < gameState.canvas.width; x += gridSize) {
        gameState.ctx.moveTo(x, 0);
        gameState.ctx.lineTo(x, gameState.canvas.height);
    }
    gameState.ctx.stroke();
    
    // Draw horizontal lines
    gameState.ctx.beginPath();
    for (let y = 0; y < gameState.canvas.height; y += gridSize) {
        gameState.ctx.moveTo(0, y);
        gameState.ctx.lineTo(gameState.canvas.width, y);
    }
    gameState.ctx.stroke();
}

/**
 * Draw the player character
 */
function drawPlayer() {
    // Draw player body (red square)
    gameState.ctx.fillStyle = player.color;
    gameState.ctx.fillRect(player.x, player.y, player.width, player.height);
    
    // Add a subtle inner highlight for visual appeal
    gameState.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
    gameState.ctx.fillRect(player.x + 3, player.y + 3, player.width - 6, 8);
    
    // Add a darker border for definition
    gameState.ctx.strokeStyle = '#991b1b';
    gameState.ctx.lineWidth = 2;
    gameState.ctx.strokeRect(player.x, player.y, player.width, player.height);
    
    // Draw player "eyes" (small white dots)
    gameState.ctx.fillStyle = '#ffffff';
    gameState.ctx.fillRect(player.x + 10, player.y + 12, 6, 6);
    gameState.ctx.fillRect(player.x + player.width - 16, player.y + 12, 6, 6);
    
    // Draw direction indicator based on velocity
    if (Math.abs(player.velocityX) > 0.5) {
        gameState.ctx.fillStyle = player.velocityX > 0 ? '#22c55e' : '#3b82f6';
        const indicatorSize = 8;
        const indicatorX = player.velocityX > 0 ? 
            player.x + player.width + 5 : 
            player.x - indicatorSize - 5;
        gameState.ctx.fillRect(
            indicatorX, 
            player.y + player.height / 2 - indicatorSize / 2, 
            indicatorSize, 
            indicatorSize
        );
    }
}

/**
 * Update debug information
 * @param {number} currentTime - Current timestamp
 * @param {number} elapsedTime - Elapsed time since last frame
 */
function updateDebugInfo(currentTime, elapsedTime) {
    gameState.debugInfo.frameCount++;
    
    // Update FPS every second
    if (currentTime - gameState.debugInfo.lastFpsUpdate >= 1000) {
        gameState.debugInfo.fps = Math.round(
            (gameState.debugInfo.frameCount * 1000) / (currentTime - gameState.debugInfo.lastFpsUpdate)
        );
        gameState.debugInfo.frameCount = 0;
        gameState.debugInfo.lastFpsUpdate = currentTime;
    }
    
    // Calculate lag (difference between actual and target frame time)
    gameState.debugInfo.lag = Math.abs(elapsedTime - GAME.MS_PER_UPDATE);
}

/**
 * Draw debug information on the canvas
 */
function drawDebugInfo() {
    const ctx = gameState.ctx;
    const debugX = 10;
    let debugY = 30;
    const lineHeight = 20;
    
    // Draw debug background panel
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(5, 5, 260, 180);
    
    // Draw debug text
    ctx.fillStyle = '#4cc9f0';
    ctx.font = '16px monospace';
    ctx.textAlign = 'left';
    
    // Game Loop Info header
    ctx.fillStyle = '#ffcc00';
    ctx.fillText('=== GAME LOOP INFO ===', debugX, debugY);
    debugY += lineHeight;
    
    // FPS
    ctx.fillStyle = gameState.debugInfo.fps >= 55 ? '#4ade80' : '#f87171';
    ctx.fillText(`FPS: ${gameState.debugInfo.fps} (Target: ${GAME.TARGET_FPS})`, debugX, debugY);
    debugY += lineHeight;
    
    // Frame time
    const frameTime = 1000 / Math.max(gameState.debugInfo.fps, 1);
    ctx.fillStyle = '#4cc9f0';
    ctx.fillText(`Frame: ${frameTime.toFixed(1)}ms`, debugX, debugY);
    debugY += lineHeight;
    
    // Lag
    ctx.fillStyle = gameState.debugInfo.lag < 2 ? '#4ade80' : '#f87171';
    ctx.fillText(`Lag: ${gameState.debugInfo.lag.toFixed(2)}ms`, debugX, debugY);
    debugY += lineHeight;
    
    // Canvas size
    ctx.fillStyle = '#c084fc';
    ctx.fillText(`Canvas: ${gameState.canvas.width} x ${gameState.canvas.height}`, debugX, debugY);
    debugY += lineHeight;
    
    // Game state
    ctx.fillStyle = gameState.isRunning ? '#4ade80' : '#f87171';
    ctx.fillText(`State: ${gameState.isRunning ? 'RUNNING' : 'PAUSED'}`, debugX, debugY);
    debugY += lineHeight;
    
    // Player info header
    ctx.fillStyle = '#ffcc00';
    ctx.fillText('=== PLAYER INFO ===', debugX, debugY);
    debugY += lineHeight;
    
    // Player position
    ctx.fillStyle = '#ef4444';
    ctx.fillText(`Position: (${Math.floor(player.x)}, ${Math.floor(player.y)})`, debugX, debugY);
    debugY += lineHeight;
    
    // Player velocity
    ctx.fillStyle = player.velocityX !== 0 ? '#22c55e' : '#94a3b8';
    ctx.fillText(`Velocity X: ${player.velocityX.toFixed(2)} px/sec`, debugX, debugY);
    debugY += lineHeight;
    
    // Player size
    ctx.fillText(`Size: ${player.width} x ${player.height}`, debugX, debugY);
    debugY += lineHeight;
    
    // Controls info
    ctx.fillStyle = '#ffcc00';
    ctx.fillText('=== CONTROLS ===', debugX, debugY);
    debugY += lineHeight;
    
    // Key states
    ctx.fillStyle = keys.a || keys.arrowLeft ? '#22c55e' : '#ef4444';
    ctx.fillText(`A/←: ${keys.a || keys.arrowLeft ? 'PRESSED' : 'RELEASED'}`, debugX, debugY);
    debugY += lineHeight;
    
    ctx.fillStyle = keys.d || keys.arrowRight ? '#22c55e' : '#ef4444';
    ctx.fillText(`D/→: ${keys.d || keys.arrowRight ? 'PRESSED' : 'RELEASED'}`, debugX, debugY);
}

// Handle window focus/blur to pause/resume game
window.addEventListener('blur', () => {
    console.log('Game paused (window lost focus)');
    gameState.isRunning = false;
    if (gameState.animationFrameId) {
        cancelAnimationFrame(gameState.animationFrameId);
        gameState.animationFrameId = null;
    }
});

window.addEventListener('focus', () => {
    console.log('Game resumed (window gained focus)');
    if (!gameState.isRunning) {
        gameState.isRunning = true;
        startGameLoop();
    }
});

// Export for debugging
window.gameState = gameState;
window.GAME = GAME;
window.player = player;
window.keys = keys;
